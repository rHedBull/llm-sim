# Data Model: LLM-Based Reasoning Components

**Feature**: 004-new-feature-i
**Date**: 2025-09-30
**Status**: Complete

This document defines the data structures for LLM-based reasoning integration into the simulation system.

---

## Core Entities

### 1. LLMReasoningChain

**Purpose**: Captures the full reasoning output from an LLM call for auditability and debugging.

**Fields**:
- `component` (str): Component that made the LLM call ("agent", "validator", "engine")
- `agent_name` (str, optional): Name of agent if component is "agent"
- `prompt` (str): Full prompt sent to LLM
- `response` (str): Raw LLM response
- `reasoning` (str): Extracted reasoning explanation
- `timestamp` (datetime): When the LLM call was made
- `duration_ms` (int): How long the LLM call took
- `model` (str): LLM model used (e.g., "gemma:3")
- `retry_count` (int): Number of retries (0 for first attempt, 1 for single retry)

**Validation Rules**:
- `component` must be one of: "agent", "validator", "engine"
- `duration_ms` must be non-negative
- `retry_count` must be 0 or 1 (per spec FR-014)
- `prompt` and `response` must be non-empty strings

**State Transitions**: Immutable once created (for audit trail integrity)

---

### 2. PolicyDecision (Agent Output)

**Purpose**: Represents an agent's LLM-generated policy decision.

**Fields**:
- `action` (str): Specific policy action description (flexible string format, not enum)
- `reasoning` (str): Step-by-step LLM explanation of why this action is appropriate
- `confidence` (float): LLM's confidence in the decision (0.0-1.0)

**Validation Rules**:
- `action` must be non-empty string (1-500 characters)
- `reasoning` must be non-empty string (10-2000 characters)
- `confidence` must be between 0.0 and 1.0 inclusive
- `action` must not contain newlines (single-line action description)

**Relationships**:
- Generated by Agent component
- Consumed by Validator component
- Embedded in Action entity

**State Transitions**: Immutable once generated

---

### 3. ValidationResult (Validator Output)

**Purpose**: Represents the Validator's LLM-based domain validation decision.

**Fields**:
- `is_valid` (bool): Whether the action is valid for the simulation domain
- `reasoning` (str): Step-by-step LLM explanation of domain determination
- `confidence` (float): LLM's confidence in the validation (0.0-1.0)
- `action_evaluated` (str): The action string that was validated (for traceability)

**Validation Rules**:
- `reasoning` must be non-empty string (10-2000 characters)
- `confidence` must be between 0.0 and 1.0 inclusive
- `action_evaluated` must match the original action string exactly

**Relationships**:
- Generated by Validator component
- Consumed by Engine component
- Referenced by Action entity (via validation fields)

**State Transitions**: Immutable once generated

---

### 4. StateUpdateDecision (Engine Output)

**Purpose**: Represents the Engine's LLM-based decision on how to update simulation state.

**Fields**:
- `new_interest_rate` (float): The calculated interest rate after applying the action
- `reasoning` (str): Step-by-step LLM explanation of how the new rate was determined
- `confidence` (float): LLM's confidence in the calculation (0.0-1.0)
- `action_applied` (str): The validated action that was applied (for traceability)

**Validation Rules**:
- `new_interest_rate` must be a valid percentage (typically 0.0-20.0, but flexible)
- `reasoning` must be non-empty string (10-2000 characters)
- `confidence` must be between 0.0 and 1.0 inclusive
- `action_applied` must match the validated action string exactly

**Relationships**:
- Generated by Engine component
- Used to create new SimulationState
- Embedded in state transition history

**State Transitions**: Immutable once generated

---

## Inheritance Architecture

### Three-Tier Class Hierarchy

The implementation follows a three-tier inheritance pattern for all components:

```
Base (existing) → LLM-Enabled Abstract → Concrete Implementation

Agent (existing ABC)
  ↓
LLMAgent (new ABC) - adds LLM reasoning capability
  ↓
EconLLMAgent (concrete) - economic domain implementation

Validator (existing ABC)
  ↓
LLMValidator (new ABC) - adds LLM domain validation
  ↓
EconLLMValidator (concrete) - economic domain implementation

Engine (existing ABC)
  ↓
LLMEngine (new ABC) - adds LLM state reasoning
  ↓
EconLLMEngine (concrete) - economic domain implementation
```

**Rationale**:
- **Base layer** (existing): Defines core simulation interface
- **LLM layer** (new abstract): Adds LLM reasoning infrastructure (client, prompts, retry logic)
- **Concrete layer** (new): Domain-specific implementations (economic, military, etc.)

This allows future domain types (military, social, etc.) to reuse the LLM infrastructure by implementing their own concrete classes.

---

## Modified Entities

### 5. Action (Extended)

**Existing Fields** (from current implementation):
- `agent_name` (str)
- `action_type` (ActionType enum) - **TO BE REMOVED**
- `parameters` (Dict[str, Any]) - **TO BE REMOVED**
- `validated` (bool)
- `validation_timestamp` (datetime, optional)

**New Fields**:
- `action_string` (str): Flexible action description (replaces action_type + parameters)
- `policy_decision` (PolicyDecision): LLM-generated policy decision from Agent
- `validation_result` (ValidationResult, optional): LLM validation result (populated after validation)
- `reasoning_chain_id` (str, optional): Reference to LLMReasoningChain for Agent's reasoning

**Migration Strategy**:
- Phase 1: Add new fields, keep old fields for backward compatibility
- Phase 2: Migrate existing code to use `action_string` instead of `action_type`
- Phase 3: Remove deprecated fields (ActionType enum, parameters dict)

**Validation Rules** (updated):
- `action_string` must be non-empty (1-500 characters)
- `policy_decision` must be valid PolicyDecision instance
- `validation_result` must be populated if `validated` is True
- Either old fields (action_type + parameters) OR new fields (action_string + policy_decision) must be present

---

### 6. SimulationState (Extended)

**Existing Fields**:
- `turn` (int)
- `agents` (Dict[str, AgentState])
- `global_state` (GlobalState)

**New Fields**:
- `reasoning_chains` (List[LLMReasoningChain]): All LLM reasoning chains for this turn (for auditability)
- `state_update_decision` (StateUpdateDecision, optional): Engine's LLM reasoning for state transition

**Validation Rules** (updated):
- `reasoning_chains` list can be empty (for backward compatibility with non-LLM simulations)
- `reasoning_chains` should contain 1 chain per agent + 1 validator chain + 1 engine chain in typical turn
- `state_update_decision` is None only for initial state (turn 0)

**Storage**: In-memory only during simulation (per spec FR-018), output at simulation end (per spec FR-019)

---

### 7. LLMConfig (New Configuration Entity)

**Purpose**: Configuration for LLM client behavior.

**Fields**:
- `model` (str): Model name (default: "gemma:3")
- `host` (str): Ollama server URL (default: "http://localhost:11434")
- `timeout` (float): Request timeout in seconds (default: 60.0)
- `max_retries` (int): Maximum retry attempts (default: 1, per spec FR-014)
- `temperature` (float): LLM temperature parameter (default: 0.7)
- `stream` (bool): Enable streaming responses (default: True)

**Validation Rules**:
- `timeout` must be positive (5.0-300.0 seconds recommended)
- `max_retries` must be exactly 1 (per spec FR-014)
- `temperature` must be between 0.0 and 2.0
- `model` must be non-empty string
- `host` must be valid URL format

**Relationships**:
- Embedded in SimulationConfig
- Used by LLMClient utility class

---

### 8. ValidatorConfig (Extended)

**Existing Fields**:
- `type` (str): Validator type identifier

**New Fields**:
- `domain` (str, optional): Simulation domain for validation (e.g., "economic", "military", "social")
- `permissive` (bool): Whether to use permissive validation (default: True per spec FR-005a)

**Validation Rules**:
- `type` can now be "llm_validator" (in addition to existing "always_valid")
- `domain` is required if type is "llm_validator"
- `permissive` defaults to True for LLM validator

---

## Relationships Diagram

```
SimulationOrchestrator
  ├─ creates → Agent (with LLMClient)
  ├─ creates → Validator (with LLMClient)
  └─ creates → Engine (with LLMClient)

Agent
  └─ produces → PolicyDecision
                 └─ embedded in → Action
                                   └─ validated by → Validator
                                                      └─ produces → ValidationResult
                                                                     └─ consumed by → Engine
                                                                                       └─ produces → StateUpdateDecision
                                                                                                      └─ creates → SimulationState

LLMReasoningChain
  └─ created by → Agent | Validator | Engine
                   └─ stored in → SimulationState.reasoning_chains
```

---

## Data Flow

### Agent Decision Flow
1. Agent receives `SimulationState`
2. Agent constructs prompt from state indicators
3. Agent calls LLM via LLMClient (with retry logic)
4. Agent parses LLM response into `PolicyDecision`
5. Agent creates `LLMReasoningChain` (logged at DEBUG level per spec FR-017)
6. Agent creates `Action` with `action_string` and `policy_decision`

### Validator Flow
1. Validator receives `Action` with `policy_decision`
2. Validator constructs domain validation prompt
3. Validator calls LLM via LLMClient (with retry logic)
4. Validator parses LLM response into `ValidationResult`
5. Validator creates `LLMReasoningChain` (logged at DEBUG level)
6. If `is_valid` is False: Validator rejects action (Engine will skip, per spec FR-008)
7. If `is_valid` is True: Validator marks Action as validated

### Engine State Update Flow
1. Engine receives validated `Action`
2. Engine constructs state update prompt from current state + action
3. Engine calls LLM via LLMClient (with retry logic)
4. Engine parses LLM response into `StateUpdateDecision`
5. Engine creates `LLMReasoningChain` (logged at DEBUG level)
6. Engine applies `new_interest_rate` to create new `SimulationState`
7. Engine attaches all `LLMReasoningChain` instances to new state

---

## Error Handling Data Flow

### LLM Failure (per spec FR-014, FR-015, FR-016)
1. LLMClient calls Ollama
2. If failure (5xx, timeout, invalid response):
   - Retry exactly once (with exponential backoff + jitter)
3. If second attempt fails:
   - Log prominent ERROR message (per spec FR-015): "LLM_FAILURE: Component={component} Agent={agent} Error={error}"
   - Raise LLMFailureException
   - Simulation step aborts (per spec FR-016)

### Validation Rejection (per spec FR-008)
1. Validator determines `is_valid` = False
2. Validator logs `ValidationResult.reasoning` at DEBUG level
3. Engine receives rejected action
4. Engine logs INFO message: "SKIPPED Agent [name] due to unvalidated Action"
5. Engine proceeds to next agent (does not abort simulation)

---

## Migration Path from Existing Data Model

### Phase 1: Add New Fields (Backward Compatible)
- Add new fields to Action, SimulationState with optional/default values
- Old code continues using ActionType enum
- New LLM-based code uses action_string

### Phase 2: Dual Support
- Update Agent/Validator/Engine to accept both old and new formats
- Tests cover both old and new data structures
- Logs indicate whether LLM or legacy mode is active

### Phase 3: Deprecation
- Remove ActionType enum
- Remove parameters dict from Action
- All code uses action_string + policy_decision
- Update all tests to use new format

---

## Validation Summary

All entities support the following quality attributes:

- **Type Safety**: Pydantic models with strict typing (per constitution check)
- **Immutability**: Reasoning chains and decisions are immutable for audit integrity
- **Traceability**: Every decision links back to original action/state via string references
- **Explainability**: Every entity includes LLM reasoning field (per spec FR-003, FR-006, FR-010)
- **Auditability**: Full reasoning chains logged at DEBUG level (per spec FR-017)

---

## Testing Implications

### Contract Tests Required
- PolicyDecision parsing from LLM JSON output
- ValidationResult parsing from LLM JSON output
- StateUpdateDecision parsing from LLM JSON output
- LLMReasoningChain creation and immutability

### Unit Tests Required
- Field validation rules for each entity
- Confidence value bounds (0.0-1.0)
- String length constraints
- Immutability enforcement

### Integration Tests Required
- Full data flow: Agent → Validator → Engine → SimulationState
- Reasoning chain propagation through state history
- Error data flow: LLM failure → Exception → Abort
- Validation rejection data flow: Validator → Engine skip

---

This data model maintains backward compatibility with existing Action/SimulationState structures while adding LLM reasoning capabilities as specified in functional requirements FR-001 through FR-019.